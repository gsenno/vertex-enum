'''
Created on 23 Oct 2018

@author: gsenno
'''import cvxopt as cvximport numpy as npimport picos as sdpfrom problem import *from semidefinite import *from tests import printMatricesdef findMaxQuantumViolation(bellIneq,N,K,d,rho):    prob = QuantumBilinearProblem()    dims = [d*np.ones((1,N*K)),d*np.ones((1,N*K))]    J = constructJMatrix(bellIneq,N,K,d,rho)    prob.init_matrix_form(dims,J);        def constructJMatrix(bellIneq,N,K,d,rho):    J = np.zeros((N*K,N*K,d*d,d*d))    bellCoeff = 0;    for x in range(N):        for y in range(N):            for a in range(K):                for b in range(K):                    J[a+N*x][b+N*y]=bellIneq[bellCoeff]*rho*(-1)                    bellCoeff += 1    return J.tolist()
def computeBellValue(N, K, rho, prob, functional):    products = []    for x in range(N):        for y in range(N):            for a in range(K):                for b in range(K):                    products.append(np.trace(rho*np.kron(prob.matsolX(a+N*x),prob.matsolY(b+N*y))))    return np.dot(np.array(functional),products)if __name__ == '__main__':    parties = 2    N = 3    K = 3    dim = 2    prob = QuantumBilinearProblem()    #rho=np.matrix([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]])    rho=np.matrix([[0,0,0,0],[0,1/2,-1/2,0],[0,-1/2,1/2,0],[0,0,0,0]])            #functional = [0,0,0,0,0,0,0,0,0,0.33333333,0,0,0,0,0,0,0,0,0,0,0,0.33333333,0,0,0,0,0,0.66666667,0.33333333,0,0,0,0,0,0,0,-0.33333333,0,0,0,0,0,0,0,0,-0.33333333,0,0,0,0,0,0,0,0,0.33333333,0.66666667,0,0,0,0,0,0,0,-0.33333333,0,0,0,0,0,0,0,0,-0.33333333,0,0,0,0,0,0,0,0]    #functional = [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]    #functional=[0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]    functional=[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]        J=constructJMatrix(functional, N, K, dim, rho)    dims = (dim*np.ones((parties,N*K),np.int8)).tolist()    prob.init_matrix_form(dims,J)    prob.add_constraint(prob.matvarX(0) == prob.matvarX(0).H)    prob.add_constraint(prob.matvarX(0) >> 0)        prob.add_constraint(prob.matvarX(1) == prob.matvarX(1).H)    prob.add_constraint(prob.matvarX(1) >> 0)    prob.add_constraint(prob.matvarX(2) == prob.matvarX(2).H)    prob.add_constraint(prob.matvarX(2) >> 0)    prob.add_constraint(prob.matvarX(3) == prob.matvarX(3).H)    prob.add_constraint(prob.matvarX(3) >> 0)    prob.add_constraint(prob.matvarX(4) == prob.matvarX(4).H)    prob.add_constraint(prob.matvarX(4) >> 0)    prob.add_constraint(prob.matvarX(4)-10 ** (-3) >>0)    prob.add_constraint(prob.matvarX(5) == prob.matvarX(5).H)    prob.add_constraint(prob.matvarX(5) >> 0)    prob.add_constraint(prob.matvarX(5)-10 ** (-3) >>0)        prob.add_constraint(prob.matvarX(6) == prob.matvarX(6).H)    prob.add_constraint(prob.matvarX(6) >> 0)    prob.add_constraint(prob.matvarX(6)-10 ** (-3) >>0)    prob.add_constraint(prob.matvarX(7) == prob.matvarX(7).H)    prob.add_constraint(prob.matvarX(7) >> 0)    prob.add_constraint(prob.matvarX(8) == prob.matvarX(8).H)    prob.add_constraint(prob.matvarX(8) >> 0)
#             prob.add_constraint(prob.matvarY(0) == prob.matvarY(0).H)    prob.add_constraint(prob.matvarY(0) >> 0)    prob.add_constraint(prob.matvarY(1) == prob.matvarY(1).H)    prob.add_constraint(prob.matvarY(1) >> 0)    prob.add_constraint(prob.matvarY(2) == prob.matvarY(2).H)    prob.add_constraint(prob.matvarY(2) >> 0)    prob.add_constraint(prob.matvarY(2)-10 ** (-3) >>0)    prob.add_constraint(prob.matvarY(3) == prob.matvarY(3).H)    prob.add_constraint(prob.matvarY(3) >> 0)    prob.add_constraint(prob.matvarY(4) == prob.matvarY(4).H)    prob.add_constraint(prob.matvarY(4) >> 0)    prob.add_constraint(prob.matvarY(5) == prob.matvarY(5).H)    prob.add_constraint(prob.matvarY(5) >> 0)    prob.add_constraint(prob.matvarY(6) == prob.matvarY(6).H)    prob.add_constraint(prob.matvarY(6) >> 0)    prob.add_constraint(prob.matvarY(7) == prob.matvarY(7).H)    prob.add_constraint(prob.matvarY(7) >> 0)    prob.add_constraint(prob.matvarY(8) == prob.matvarY(8).H)    prob.add_constraint(prob.matvarY(8) >> 0)        prob.add_constraint(prob.varX()[0]+prob.varX()[4] + prob.varX()[8] == 2./np.sqrt(2))    prob.add_constraint(prob.varX()[1]+prob.varX()[5] + prob.varX()[9] < 10**-20.)    prob.add_constraint(prob.varX()[1]+prob.varX()[5] + prob.varX()[9] > 0.)    prob.add_constraint(prob.varX()[2]+prob.varX()[6] + prob.varX()[10] == 0.)    prob.add_constraint(prob.varX()[3]+prob.varX()[7] + prob.varX()[11] == 0.)    prob.add_constraint(prob.varX()[12]+prob.varX()[16]+prob.varX()[20] == 2./np.sqrt(2))    prob.add_constraint(prob.varX()[13]+prob.varX()[17]+prob.varX()[21] == 0)    prob.add_constraint(prob.varX()[14]+prob.varX()[18]+prob.varX()[22] == 0.)    prob.add_constraint(prob.varX()[15]+prob.varX()[19]+prob.varX()[23] == 0.)    prob.add_constraint(prob.varX()[24]+prob.varX()[28]+prob.varX()[32] == 2./np.sqrt(2))    prob.add_constraint(prob.varX()[25]+prob.varX()[29]+prob.varX()[33] == 0)    prob.add_constraint(prob.varX()[26]+prob.varX()[30]+prob.varX()[34] == 0.)    prob.add_constraint(prob.varX()[27]+prob.varX()[31]+prob.varX()[35] == 0.)    prob.add_constraint(prob.varY()[0]+prob.varY()[4] + prob.varY()[8] == 2./np.sqrt(2))    prob.add_constraint(prob.varY()[1]+prob.varY()[5] + prob.varY()[9] == 0.)    prob.add_constraint(prob.varY()[2]+prob.varY()[6] + prob.varY()[10] == 0.)    prob.add_constraint(prob.varY()[3]+prob.varY()[7] + prob.varY()[11] == 0.)    prob.add_constraint(prob.varY()[12]+prob.varY()[16]+prob.varY()[20] == 2./np.sqrt(2))    prob.add_constraint(prob.varY()[13]+prob.varY()[17]+prob.varY()[21] == 0)    prob.add_constraint(prob.varY()[14]+prob.varY()[18]+prob.varY()[22] == 0.)    prob.add_constraint(prob.varY()[15]+prob.varY()[19]+prob.varY()[23] == 0.)    prob.add_constraint(prob.varY()[24]+prob.varY()[28]+prob.varY()[32] == 2./np.sqrt(2))    prob.add_constraint(prob.varY()[25]+prob.varY()[29]+prob.varY()[33] == 0)    prob.add_constraint(prob.varY()[26]+prob.varY()[30]+prob.varY()[34] == 0.)    prob.add_constraint(prob.varY()[27]+prob.varY()[31]+prob.varY()[35] == 0.)        
    prob.solve(verb = 1, maxiter = STD_MAXITER, allowedgap = STD_ALLOWEDGAP)        print("Bell value=",computeBellValue(N,K,rho,prob,functional))    printMatrices(prob)    for i in range(9):        if np.all(np.linalg.eigvals(prob.matsolX(i)) >= 0)==False:            print("X",i,prob.matsolX(i))        if np.all(np.linalg.eigvals(prob.matsolY(i)) >= 0)==False:            print("Y",i,prob.matsolY(i))    