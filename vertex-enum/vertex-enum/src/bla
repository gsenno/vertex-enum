import numpy as np
import cdd as cdd



def buildVRepresentation(vertices):
    vRep = np.zeros((len(vertices), 1+len(vertices[0])))
    for i in range(len(vRep)):
        vRep[i][0] = 1
        vRep[i][1:] = vertices[i]
    
    return vRep

def getInequalities(poly):
    ext = poly.get_inequalities()
    inequalities = map(lambda x:list(x), list(ext.__getitem__(slice(ext.row_size))))
    return inequalities

if __name__ == '__main__':
    
    K = 2
    N = 3
    
    A=np.zeros((1548,82))
    #VALUES OF THE INEQUALITIES
    A[45:774,0]=63
    A[774:1503,0]=1
    
    #IMPOSING THE COMPONENTS 0 OF THE FUNCTIONAL
    for j in range (1, 28):
        A[j-1, 3*j]=1
          
    for j in range (0, 9):
        A[27 +2*j, 7 + 9*j]= 1
        A[28 + 2*j, 8 + 9*j] = 1 
     
    for j in range (1,28):
        A[1502+j,3*j]=-1
    
    for j in range (0, 9):
        A[1530 +2*j, 7 + 9*j]= -1
        A[1531 + 2*j, 8 + 9*j] = -1 
     
    #IMPOSING THE REST OF CONSTRAINTS    
    B=np.eye(9);
    i=0
    for x0 in range (0,3):
        for x1 in range (0,3):
            for x2 in range (0,3):
                for y0 in range (0,3):
                    for y1 in range (0,3):
                        for y2 in range (0,3):
                            v0=B[3*x0+y0,:]
                            v1=B[3*x0+y1,:]
                            v2=B[3*x0+y2,:]
                            v3=B[3*x1+y0,:]
                            v4=B[3*x1+y1,:]
                            v5=B[3*x1+y2,:]
                            v6=B[3*x2+y0,:]
                            v7=B[3*x2+y1,:]
                            v8=B[3*x2+y2,:]
                            vector=np.concatenate((v0,v1,v2,v3,v4,v5,v6,v7,v8))
                            A[45+i,1:]=vector
                            A[774+i,1:]=-vector
                            i=i+1  
                            
                            
    #MATRIZ QUE MULTIPLICARE POR LAS DISTRIBUCIONES DETERMINISTAS                        
    C=A[:,1:] 
    coef=A[:,0]     #CONSTRAINTS                 
     
    #CREATE THE DETERMINISTIC DISTRIBUTIONS FOR (3,2) AND THEN MULTIPLYING THEM BY THE MATRIX                       
    B=np.eye(K**2);
    i=0
    l=0
    verticesLocal=np.empty(((K**N)**2,(K*N)**2))
    for x0 in range (0,K):
        for x1 in range (0,K):
            for x2 in range (0,K):
                for y0 in range (0,K):
                    for y1 in range (0,K):
                        for y2 in range (0,K):
                            v0=B[K*x0+y0,:]
                            v1=B[K*x0+y1,:]
                            v2=B[K*x0+y2,:]
                            v3=B[K*x1+y0,:]
                            v4=B[K*x1+y1,:]
                            v5=B[K*x1+y2,:]
                            v6=B[K*x2+y0,:]
                            v7=B[K*x2+y1,:]
                            v8=B[K*x2+y2,:]
                            vector=np.concatenate((v0,v1,v2,v3,v4,v5,v6,v7,v8))
                            verticesLocal[i]=vector
                            i+=1
#                             for k in range (1,28):
#                                 vector[3*k-1]=0
#                             for k in range (0,9):
#                                 vector[6+9*k]=0
#                                 vector[7+9*k]=0
#                             vertices.add(str(vector))
#                             print(str(vector))
#                             D=np.dot(C,vector) #PRODUCT WITH THE MATRIX
#                             for k in range (0, 1548):
#                                 if D[k] > coef[k]: #COMPARING THE TWO VECTORS TO SEE IF IT FITS THE CONSTRAINTS
#                                     l=l+1
#                                            

    origin = np.zeros((K*N)**2)                 
    verticesLocalIncomplete=np.empty((len(verticesLocal)+1,len(verticesLocal[0])))
    verticesLocalIncomplete[0:len(verticesLocal)]=verticesLocal
    verticesLocalIncomplete[len(verticesLocalIncomplete)-1]=origin
    
    vRep = buildVRepresentation(verticesLocalIncomplete)
    
    mat = cdd.Matrix(vRep, number_type='fraction')
    mat.rep_type = cdd.RepType.GENERATOR
    
    poly = cdd.Polyhedron(mat)
    inequalities = getInequalities(poly)
    
    
    
#    p=np.dot(inequalities[0][1:],verticesLocalIncomplete[0])
    
                            
    #ALGUNA CONSTRAINT NO SE CUMPLE PARA ALGUNA DISTRIBUCION                        
    if l!=0: 
        print('Fail')      
    #TODAS LAS CONSTRAINTS SE CUMPLEN PARA TODAS LAS DISTRIBUCIONES
    if l==0: 
        print('I won')                 
    
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                        